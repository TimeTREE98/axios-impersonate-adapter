'use strict';

const fs = require('node:fs');
const os = require('node:os');
const path = require('node:path');
const { spawnSync } = require('node:child_process');

// step 1: find the bin directory (./curl-impersonate/bin)
const BIN_DIR = path.join(__dirname, '..', 'curl-impersonate', 'bin');
if (!fs.existsSync(BIN_DIR)) {
  throw new Error(`[curl-impersonate] missing bin directory at ${BIN_DIR}`);
}

// step 2: find the targets (curl_ prefix)
const targets = fs
  .readdirSync(BIN_DIR)
  .filter((name) => name.startsWith('curl_'))
  .filter((name) => fs.statSync(path.join(BIN_DIR, name)).isFile())
  .sort((a, b) => a.localeCompare(b));

if (targets.length === 0) {
  throw new Error(`[curl-impersonate] no targets found in ${BIN_DIR}`);
}

// step 3: parse the targets and create a capture environment
const createCaptureEnv = () => {
  const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'curl-impersonate-args-'));
  const stubPath = path.join(tmpDir, 'curl-impersonate');
  const capturePath = path.join(tmpDir, 'args.bin');

  fs.writeFileSync(
    stubPath,
    '#!/usr/bin/env bash\nif [ -z "$CURL_IMPERSONATE_CAPTURE" ]; then\n  echo "CURL_IMPERSONATE_CAPTURE not set" >&2\n  exit 1\nfi\nprintf "%s\\0" "$@" > "$CURL_IMPERSONATE_CAPTURE"\n',
    { mode: 0o755 },
  );

  return {
    tmpDir,
    stubPath,
    capturePath,
  };
};

const captureArgsFromTarget = (targetPath, captureEnv, baseEnv) => {
  const { tmpDir, capturePath } = captureEnv;
  const targetName = path.basename(targetPath);
  const targetCopyPath = path.join(tmpDir, targetName);

  try {
    fs.copyFileSync(targetPath, targetCopyPath);
    fs.chmodSync(targetCopyPath, 0o755);

    const result = spawnSync(targetCopyPath, [], {
      env: {
        ...baseEnv,
        CURL_IMPERSONATE_CAPTURE: capturePath,
      },
      encoding: 'utf8',
    });

    if (result.error) {
      throw result.error;
    }

    if (result.status !== 0) {
      throw new Error(`[curl-impersonate] failed to capture args for ${targetName}: ${result.stderr || 'unknown error'}`);
    }

    if (!fs.existsSync(capturePath)) {
      throw new Error(`[curl-impersonate] missing captured args for ${targetName}`);
    }

    const captured = fs.readFileSync(capturePath);
    return captured
      .toString('utf8')
      .split('\0')
      .filter((arg) => arg.length > 0);
  } finally {
    fs.rmSync(targetCopyPath, { force: true });
  }
};

const profiles = [];
const defaults = {};

const captureEnv = createCaptureEnv();
const baseEnv = { ...process.env };

try {
  for (const target of targets) {
    const profile = target.replace(/^curl_/, '');
    const profileEntry = { headers: {}, args: [] };

    const targetPath = path.join(BIN_DIR, target);
    const _args = captureArgsFromTarget(targetPath, captureEnv, baseEnv);

    for (let i = 0; i < _args.length; i++) {
      const arg = _args[i];
      if (['-H', '--header'].includes(arg)) {
        const headerValue = _args[i + 1];
        if (!headerValue) {
          throw new Error(`[curl-impersonate] missing header value in ${target}`);
        }
        const [key, value] = headerValue.split(':');
        profileEntry.headers[key.trim()] = value.trim();
      } else {
        profileEntry.args.push(arg);
      }
    }

    profiles.push(profile);
    defaults[profile] = profileEntry;
  }
} finally {
  fs.rmSync(captureEnv.tmpDir, { recursive: true, force: true });
}

let impersonate = `// This file is auto-generated by scripts/generate-impersonates.js\n\nexport const PROFILES = [\n${profiles
  .map((profile) => `  '${profile}',`)
  .join('\n')}\n] as const;\n\nexport type Profile = (typeof PROFILES)[number];\n\n`;

impersonate += `export type Defaults = {\n  headers: Record<string, string>;\n  args: string[];\n};\n\nexport const DEFAULTS: Record<string, Defaults> = ${JSON.stringify(
  defaults,
  null,
  2,
)};\n`;

fs.writeFileSync(path.join('src', 'impersonate.ts'), impersonate, 'utf8');
